\documentclass[a4paper]{article}
\usepackage{import}
\input{../../setup.sty}

\onehalfspacing
\title{Fondamenti di Informatica | Esercizi}
\author{Università di Verona\\Imbriani Paolo - VR500437\\Prof.ssa Isabella Mastroeni}

\begin{document}

\begin{figure}
    \centering
    \includegraphics[width=0.3\textwidth]{../UniversityofVerona.png}
    \label{fig:centered-image}
\end{figure}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{Grammatiche CF}

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 1.25}]
    Dimostrare che il seguente linguaggio sia context-free:
    \[
        L = \{0^n1^m0^{n+m} \; | \; n,m \in \mathbb{N}\}
    \]
    \end{tcolorbox}
\textbf{Soluzione: }

\begin{proof}
Dimostriamo la seconda tesi per induzione su $n$.
\\
\textbf{Base:} Sia $n=2$. L'unica derivazione di lunghezza 2 è $S \rightarrow A \rightarrow \varepsilon$ dove 
$\varepsilon \in L$.
\\
\textbf{Passo induttivo:} Supponiamo che la tesi sia vera per ogni derivazione di lunghezza minore o uguale a $n$.
\[
    \forall k \in \mathbb{N} \; . \; k \le n : S \Rightarrow_{k} x \implies x \in L \; con \; x = 0^i1^j0^{i+j} \; con \; i,j \ge 0
\]
Scomponiamo la derivazione a partire dalle prime produzioni.
Dimostriamo che vale per S $\Rightarrow_{n+1} x$ con $x \in \{0,1\}^{\ast}$.
L'ultima produzione sarà sicuramente $A \rightarrow \varepsilon$ ovvero:
\[
    \text{[COND 1]} \quad S \Rightarrow_{n+1} x \equiv \overbrace{S \Rightarrow_{n} yAz \rightarrow y\varepsilon z}^{n+1} = yz = x
\]
Osservando $COND 1$ notiamoc he per come è fatta la grammatica $y$ e $z$ possono essere scritte come:
\begin{itemize}
    \item $y = 0^h1^k$ e $z = 0^l$ con $h,k,l \ge 0$ 
    \[
        S \Rightarrow_{n} yAz \equiv S \Rightarrow_{n-1} \hat{y}A\hat{z} \rightarrow \hat{y}10\hat{z} = yz
    \]
    \item $y = 0^h$ e $z = 0^l$ con $h,l \ge 0$
\end{itemize}
Consideriamo il primo caso. Allora possiamo prendere la de


\end{proof}

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 1.18}]
Dimostrare che il seguente linguaggio sia context-free:
\[
    L = \{0^{2n}10^{n+m} \; | \; m,n \ge 0\}
\]
\end{tcolorbox}
\textbf{Soluzione:} Intutivamente sappiamo che 
il primo gruppo di zeri e il secondo gruppo di zeri sono legati da una relazione di dipendenza.
Per ogni 2 zeri nel primo gruppo, c'è un solo 0 nel secondo gruppo.
Tuttavia il secondo gruppo di zeri ha un numero variabile di zeri in più (m).
Possiamo quindi costruire una grammatica che generi il linguaggio come segue:

\[
  S \rightarrow 00S0 \; | \; S0 \; | 1
\]
Dimostriamo che tale grammatica genera il linguaggio L.
Abbiamo due tesi da dimostrare:
\begin{enumerate}
    \item $x \in L \wedge x=0^{2i}10^{i+j}$ con $i,j \ge 0 \implies S \Rightarrow_{\ast} x$ per induzione su $|x|$.
    \item $S \Rightarrow_{n} x \implies x \in L \wedge x=0^{2i}10^{i+j}$ con $i,j \ge 0$ per induzione su $n$.
\end{enumerate}

\begin{proof}
\textbf{1.} Dimostriamo la prima tesi per induzione su $|x|$.
\\
\textbf{Base:} $|x|=1 \implies x=1$ con $i=0,j=0$. Allora $S \Rightarrow 1$.
\\
\textbf{Passo induttivo:} Supponiamo che la tesi sia vera per ogni stringa di lunghezza minore o uguale a $n$.
\[
    \forall x \in \Sigma^{\ast} \; . \; |x| < n, \; x \in L \wedge x = 0^{2i}10^{i+j} \implies S \Rightarrow_{\ast} x
\]
Dimostriamo che vale per $|x|=n+1$. Il caso $i=j=0$ lo abbiamo già visto nella base.
Supponiamo $i>0$. Allora $x$ può essere scritto come $x=00x'0$ con $x'=0^{2(i-1)}10^{(i-1)+j}$.
Inoltre abbiamo il caso in cui $j>1$ e $i=0$ in cui $x$ può essere scritto come $x=y0$ con $y=10^{j-1}$.
In entrambi i casi abbiamo che $|x'| < |x| = n+1$, quindi possiamo applicare l'ipotesi induttiva e ottenere 
che esiste una derivazione $S \Rightarrow_{\ast} x'$.
Vediamo i due casi:
\begin{itemize}
    \item Sia $x' = 0^{2(i-1)}10^{(i-1)+j}$ con $i > 1$. Per come è fatta la grammatica abbiamo che 
    \[
    \begin{aligned}
        S \Rightarrow_{\ast} 0^{2(i-1)}10^{(i-1)+j} \equiv S &\Rightarrow_{\ast} 0^{2(i-2)}10^{(i-2)+j}\\
        &\rightarrow 00(0^{2(i-2)}10^{(i-2)+j})0\\
        &\rightarrow 0^{2(i-1)}10^{(i-1)+j} = x'
    \end{aligned} 
    \]
    Ma allora possiamo scrivere la derivazione:
    \[
    \begin{aligned}
        S &\Rightarrow_{\ast} 0^{2(i-2)}10^{(i-2)+j}\\
        &\rightarrow 00(0^{2(i-1)}10^{(i-1)+j})0\\
        &\rightarrow 0^{2i}10^{i+j} = x
    \end{aligned}
    \]
    \item Sia $x' = 10^{j-1}$ con $j > 1$. Per come è fatta la grammatica abbiamo che
    \[  
    \begin{aligned}
        S \Rightarrow_{\ast} 10^{j-1} \equiv S &\Rightarrow_{\ast} 10^{j-2}\\
        &\rightarrow S0^{j-2}\\
        &\rightarrow 10^{j-1} = x'
    \end{aligned}
    \]
    Ma allora possiamo scrivere la derivazione:
    \[
    \begin{aligned}
        S &\Rightarrow_{\ast} S0^{j-2}\\
        &\rightarrow S00^{j-2}\\
        &\rightarrow S0^{j-1}\\
        &\rightarrow S00^{j-1}\\
        &\rightarrow 10^{j} = x \quad \quad \square
    \end{aligned}
    \]
\end{itemize}
\end{proof}

\begin{proof}
    \textbf{2.} Dimostriamo la seconda tesi per induzione su $n$.
    \\
    \textbf{Base:} $n=1$. L'unica derivazione di lunghezza 1 è $S \rightarrow 1$ e $1 \in L$.
    \\
    \textbf{Passo induttivo:} Supponiamo che la tesi sia vera per ogni derivazione di lunghezza minore o uguale a $n$.
    \[
        \forall k \in \mathbb{N} \; . \; k \le n : S \Rightarrow_{k} x \implies x \in L \wedge x = 0^{2i}10^{i+j} \; con \; i,j \ge 0
    \]
    Scomponiamo la derivazione a partire dalle prime produzioni.
    Dimostriamo che vale per S $\Rightarrow_{n+1} x$ con $x \in \{0,1\}^{\ast}$.
    Una tale derivazione può iniziare in due modi, con le produzioni $S \rightarrow 00S0$ oppure $S \rightarrow S0$.
    Quindi so che $\exists x' \in \{0,1\}^{\ast}$ tale che:
    \[
        \text{[COND 1.1]} \quad S \Rightarrow_{n+1} x \equiv \overbrace{S \rightarrow S0 \Rightarrow_{n} \underbrace{x'}_{0^{\ast}1}0 = x}^{n+1}
    \]
    \[
        \text{[COND 1.2]} \quad S \Rightarrow_{n+1} x \equiv \overbrace{S \rightarrow 00S0 \Rightarrow_{n} 00\underbrace{x'}_{0^{\ast}1 0^{\ast}}0 = x}^{n+1}
    \]
    Consideriamo la condizione 1.1.
    Per l'ipotesi induttiva sappiamo che $S \Rightarrow_{n} x'$ con $x' \in L$ e $x' = 0^{2i}10^{i+j}$ con $i,j \ge 0$.
    Allora possiamo scrivere:
    \[
    x = x'0 = 0^{2i}10^{i+j}0 = 0^{2i}10^{i+(j+1)} \in L \text{ (per def) con } i,j+1 \ge 0
    \]
    Consideriamo la condizione 1.2.
    Per l'ipotesi induttiva sappiamo che $S \Rightarrow_{n} x'$ con $x' \in L$ e $x' = 0^{2i}10^{i+j}$ con $i,j \ge 0$.
    Allora possiamo scrivere:
    \[
    x = 00x'0 = 00(0^{2i}10^{i+j})0 = 0^{2(i+2)}10^{(i+1)+j} \in L \text{ (per def) con } i+1,j \ge 0 \quad \square
    \]
\end{proof} 

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 1.26}]
Dimostrare che la seguente famiglia di linguaggi sia context-free:
\[
    L_m = \{b^{mn}c^{4n} \; | \; n \in \mathbb{N}\}, \; \Sigma = \{a,b,c\}
\]
\end{tcolorbox}
\noindent
\textbf{Soluzione:} Consideriamo il linguaggio:
\[ 
    L_0 = \{c^{4n} \; | \; n \in \mathbb{N}\} 
\]
$L_0$ contiene una sequenza di $c$ multipla di 4, incluso la stringa vuota.
La grammatica che lo genera è la seguente:
\[
    S \rightarrow ccccS \; | \; \epsilon
\] 
Notiamo che questo linguaggio è regolare (e quindi anche CF) e possiamo vedere $L_m$ come
concatenazione di due linguaggi:
\[ 
    L_{\alpha_m} = \{b^{mn} \; | \; n \in \mathbb{N}\}
\] 
e 
\[ 
    L_0 = L_{\beta} = \{c^{4n} \; | \; n \in \mathbb{N}\} \quad \text{che sappiamo essere regolare (e quindi CF)}
\]
Ora, $L_{\alpha_m}$ sappiamo che per:
\begin{itemize}
    \item $m=0$ è il linguaggio $\{\epsilon\}$ che è regolare (e quindi CF)
    \item $m=1$ è il linguaggio $\{b^n \; | \; n \in \mathbb{N}\}$ che è regolare (e quindi CF)
\end{itemize}
$L_{\alpha_{m > 1}}$ è il linguaggio costituito da tutte le stringhe 
di $b$ con lunghezza multipla di $m$.
L'espressione regolare che lo descrive è la seguente:
\[
    (b^m)^{\ast}
\]
Di conseguenza se 
\[
    L_m = L_{\alpha_m} \cdot L_{\beta}
\]
Allora possiamo concludere che $L_m$ è context-free per ogni $m \ge 0$, 
essendo la concatenazione di due linguaggi CF.
Possiamo inoltre dire che per ogni $m$ esiste una grammatica che genera $L_m$:
\[
    S \rightarrow b^mS \; | \; \varepsilon
\]

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 1.25}]
Dimostrare che il seguente linguaggio sia context-free:
\[
    L = \{x \in \{0,1\}^\ast \; | \; |x|_0 > |x|_1\}
\]
\end{tcolorbox}
\noindent
\textbf{Soluzione:} Il linguaggio $L$ contiene tutte le stringhe
composte da 0 e 1 in cui il numero di 0 è strettamente maggiore del numero di 1.
Alcuni esempi sono $L = \{000, 0001, 0010, 0100, \\1000,
0011, 0101, 0110, 1001, 1010, 1100, 00011\}$.

Possiamo costruire una grammatica che genera il linguaggio come segue:
\[
    S \rightarrow A0A \quad A \rightarrow A1A0A \; | \; A0A1A \; | \; A0A \; | \; 0 \; | \; \varepsilon
\]
Dimostriamo che tale grammatica genera il linguaggio L. Abbiamo due tesi da dimostrare:
\begin{enumerate}
    \item $x \in L \land |x|_0 > |x|_1 \implies S \Rightarrow_{\ast} x$ per induzione su $|x|$.
    \item $S \Rightarrow_{n} x \implies x \in L \land |x|_0 > |x|_1$ per induzione su $n$.
\end{enumerate}

\begin{proof}
\textbf{1.} Dimostriamo la prima tesi per induzione su $|x|$.\\
\textbf{Base:} $|x|=1 \implies x=0$. Allora $S \Rightarrow 0$.\\
\textbf{Passo induttivo:} Supponiamo che la tesi sia vera per ogni stringa di lunghezza minore o uguale a $n$.
\[
    \forall x \in \Sigma^{\ast} \; . \; |x| \le n, \; x \in L \land |x|_0 > |x|_1 \implies S \Rightarrow_{\ast} x
\]
Dimostriamo che vale per $|x|=n+1$. Ad ogni produzione, devo sempre mantenere il vantaggio
di 0 su 1. In ogni produzione in cui aggiungo 1, devo per forza aggiungere uno 0. Se $x \in L$ diversa dalla base ($0$), allora esiste la stringa in eccesso
$0$ dentro $x$ quindi $\exists v,w \in \{0,1\}^\ast$ tali che $x = v0w$. 
Per come è fatta la grammatica 
possiamo riordinare tutte le produzioni 
in modo da generare prima tutti i simboli della stringa (alternati dal simbolo $A$)
e poi sostituire gli $A$ con le stringhe vuote o con zeri in base all'esigenza.
Prendiamo $x' = vw$, allora $|x'|_0 = |x|_0 - 1$ e $|x'|_1 = |x|_1$ quindi 
$|x'| < |x| = n+1$ e quindi possiamo applicare l'ipotesi induttiva, ovvero 
esiste $S \Rightarrow_{\ast} x'$.
Il passo iniziale ci permette di sapere con certezza 
che verranno sempre create stringhe con almeno uno 0 in più rispetto agli 1.
Per quanto detto, questa derivazione può essere riscritta come:
(dove $|v| = h$ e $|w| = k$ e $v_i$ e $w_i$ sono i simboli di $v$ e $w$ rispettivamente):
\[ 
    \begin{aligned}
        A &\Rightarrow_{\ast} x' = vw \equiv\\
        A &\Rightarrow_{\ast} Av_1A\dots Av_h A w_1 A \dots A w_k A \\
        &\Rightarrow_{h+k+1} v_1 \dots v_h w_1 \dots w_k = vw = x'
    \end{aligned}
\]
Sappiamo che $A$ può generare stringhe dove il numero di $0$ è 
uguale al numero di $1$ che hanno al massimo $|x|_0 = |x|_1$. Ma con il passo iniziale $S$ manteniamo sempre un 0 in più.
e quindi possiamo costruire:
\[
    \begin{aligned}
        S \rightarrow A\textcolor{red}{0}A &\Rightarrow_{\ast} Av_1A\dots Av_h \textcolor{red}{0} w_1 A \dots A w_k A \\
        &\Rightarrow_{h+j} v_1\dots v_h \textcolor{red}{0} w_1 \dots w_k = v\textcolor{red}{0}w = x \quad \square
    \end{aligned}
\]
\end{proof}

\section{Insiemi produttivi}


\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 1}]
Dimostrare che l'insieme
\[ 
    A = \{x \; | \; W_x = REC \implies \varphi_x (x^2) \downarrow\}
\]
oppure 
\[  
    A = \{x \; | \; W_x \neq REC \lor \varphi_x (x^2) \downarrow\}
\]
è produttivo.  
\end{tcolorbox}
\noindent
Il complemento di $A$ è:
\[
    \overline{A} = \{x \; | \; W_x = REC \land \varphi_x (x^2) \uparrow\}
\]
Notiamo come i due insiemi siano entrambi produttivi essendo che in $A$ abbiamo 
\[
    W_x \neq REC 
\]
non è possibile decidere se un insieme non è ricorsivo. 
La stessa cosa per $\overline{A}$ essendo che non è possibile decidere se
\[ 
    \varphi_x (x^2) \uparrow
\]
Per dimostrare che un insieme è produttivo dobbiamo dimostrare che 
$\overline{K} \preceq A$ o $K \preceq \overline{A}$.
Definiamo la funzione parziale ricorsiva:
\[ 
\psi(x,y) = 
\begin{cases}
    1 & x \in K \land y \neq x^2\\
    \uparrow & \text{altrimenti}
\end{cases}
\]
Costruiamo l'algoritmo per $\psi$:
\begin{lstlisting}[language=Python]
input(x,y)
if y != x^2: 
    while true
costruisci phi_x
while true
    esegui next step di phi_x(x)
    if termina: return 1
\end{lstlisting}
Per il teorema di s-m-n esiste una funzione totale e calcolabile $f$ tale che:
\[
    \varphi_{g(x)}(y) = \psi(x,y)
\]
Sappiamo che se $x \in \overline{K}$ allora $\psi(x,y) \uparrow$ per ogni $y$.
\[
\begin{aligned}
x \in K &\implies \psi(x,y) \downarrow \iff y \neq x^2\\
&\implies \varphi_{g(x)}(y) \downarrow \iff y \neq g(x)^2\\
&\implies W_{g(x)} = \mathbb{N} / \mathbb{N}^2 = \text{REC} \implies g(x) \notin A
\end{aligned}
\]
\[
\begin{aligned}
  x \notin K &\implies \forall y \; . \; \psi(x,y) \uparrow\\
  &\implies \forall y \; . \; \varphi_{g(x)}(y) \uparrow \\
  &\implies \varphi_{g(x)}(g(x)^2) \uparrow \\
    &\implies W_{g(x)} = \varnothing \implies g(x) \in A 
\end{aligned}
\]
Ora dimostriamo che $\overline{A}$ è produttivo.
Per dimostrare che $\overline{A}$ è produttivo dobbiamo dimostrare che
\[ 
    \overline{K} \preceq \overline{A} \text{ o } K \preceq A
\]
Quindi se $x \in K$ allora  $g(x) \in A$.
Definiamo la funzione parziale ricorsiva:
\[
    \psi(x,y) = \begin{cases}
        1 & \varphi_x(x) \text{ NON termina in meno di $y$ passi} \land y \in 2\mathbb{N} + 1\\
        \uparrow & y = 1\\
        \uparrow & \text{altrimenti}
    \end{cases}
\]
Costruiamo l'algoritmo per $\psi$:
\begin{lstlisting}[language=Python]
input(x,y)
if y == 1: 
    while true
if y % 2 == 0:
    while true
costruisci phi_x
for 0 to y-1
    esegui next step di phi_x(x)
    if termina
        while true
return 1
\end{lstlisting}
Per il teorema di s-m-n esiste una funzione totale e calcolabile $g$ tale che:
\[
    \varphi_{g(x)}(y) = \psi(x,y)
\]
Sappiamo che 
\[
\begin{aligned}
    x \notin K &\implies \psi(x,y) \downarrow \iff y \in 2\mathbb{N} + 1 \; \backslash \; \{1\}\\
    &\implies \forall y \in 2\mathbb{N} + 1 \backslash \{1\} \; . \; \varphi_{g(x)}(y) \downarrow\\
    &\implies W_x = 2\mathbb{N} + 1 \backslash \{1\} \in REC \land g(x)^2 \notin W_x \iff g(x) = 1\\
    &\implies g(x) \notin A
\end{aligned}
\]
\[
\begin{aligned}
    x \in K &\implies W_x = [0, n-1] \cap 2\mathbb{N} + 1 \; \backslash \; \{1\}\\
    &\implies \varphi_{g(x)}(y) \downarrow \text{ in n passi}\\
    &\implies W_{g(x)} = [0, n-1] \cap 2\mathbb{N} + 1 \; \backslash \; \{1\} \notin REC\\
    &\implies g(x) \in A
\end{aligned}
\]


\section{Successioni}
\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 1}]
Definire una successione di insiemi ricorsivi $X_n$ tale che
\[  
    \bigcup_n X_n = k \leftarrow \text{ creativo}
\]
\end{tcolorbox}

\begin{itemize}
    \item Vanno definiti $X_n$ al valore di $n$
    \item $X_n$ sono ricorsivi 
    \item Dimostrare che $\bigcup_n X_n = k$ 
\end{itemize}
\[  
    k = \{x \; |\; \varphi_x(x) \downarrow\}
\]
Sappiamo che $y \in \bigcup_n X_n$ corrisponde a $\exists n . y \in X_n$ 
e che $\downarrow$ è un $\exists n$ tale che per $\varphi_x(x)$ termina 
in $n$ passi. 
\[ 
    X_n = \{x \; |\; \varphi_x(x) \text{ termina in } n \text{ passi}\}
\]
Una volta aver mostrato questo insieme le cose da fare sono due:
\begin{itemize}
    \item $X_n$ è ricorsivo 
    \item $\bigcup_{n} X_n = k$ 
\end{itemize}
Dimostriamo che $X_n$ è ricorsivo.
Dobbiiamo costruire l'agloritmo per la funzione caratteristica di $X_n$.
\[      
    f_n(x) = \begin{cases}
        1 & \text{se } x \in X_n\\
        0 & \text{se } x \notin X_n
    \end{cases}
\]
L'algoritmo è il seguente:
\begin{lstlisting}[language=Python]
input(x)
costruisci phi_x 
for y to n-1 
    esegui un passo di phi_x(x)
    if termina return 0
esegui un passo di phi_x(x) 
if termina return 1
else return 0
\end{lstlisting}
\noindent
Questo è l'algoritmo per $f_n$ che è totale quindi $X_n$ è ricorsivo.
Ora dimostriamo che $\bigcup_n X_n = k$.
\[
\begin{aligned}
    \bigcup_n X_n &= \bigcup_n \; \{x \; | \; \varphi_x{x} \text{ termina in } n \text{ passi}\}\\
    &= \{x \; | \; \exists n \; . \; \varphi_x(x) \text{ termina in } n \text{ passi}\}\\
    &= \{x \; | \; \varphi_x(x) \downarrow\} = k
\end{aligned}
\] 

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 2}]
Definire una successione di insiemi ricorsivi $X_n$ tale che
\[  
    \bigcap_n X_n = \overline{k} \leftarrow \text{ produttivo}
\]
\end{tcolorbox}
\begin{itemize}
    \item Definite $X_n$ al variare di $n$
    \item $X_n$ sono ricorsivi
    \item Dimostrare che $\bigcap_n X_n = \overline{k}$
\end{itemize}
\[
    \bigcap_n = \forall n 
\]
\[
    \overline{k} = \{x \; | \; \varphi_x(x) \uparrow\} = 
    \{x \; | \; \forall n \; . \; \varphi_x(x) \text{ non termina in n passi}\}
\]
\begin{itemize}
    \item Definiamo:
    \[
        X_n = \{x \; | \; \varphi_x(x) \text{ non termina in n passi}\}
    \]
    Dimostriamo che $f_n(x) = \begin{cases}
        1 & \text{se } x \in X_n\\
        0 & \text{se } x \notin X_n
    \end{cases}$ è ricorsiva.
    Costruiamo l'algoritmo per $f_n$:
\begin{lstlisting}[language=Python]
input(x)
costruisci phi_x
for y to n-1  
    esegui un passo di phi_x(x)
    if termina return 1 
esegui un passo di phi_x(x)
if termina return 0
else return 1
\end{lstlisting}
\item  
\[ 
\begin{aligned}
    \bigcap_n X_n &= \bigcap_n \; \{x \; | \; \varphi_x(x) \text{ non termina in n passi}\}\\
    &= \{x \; | \; \forall n \; . \; \varphi_x(x) \text{ non termina in n passi}\}\\
    &= \{x \; | \; \varphi_x(x) \uparrow\} = \overline{k}
\end{aligned}
\]
\end{itemize}

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 3}]
Definire una successione di insiemi ricorsivi $X_n$ tale che
\[  
    A = \{x \; | \; \bigcap_n \; \overline{X_n} \preceq W_x \}
\]
\end{tcolorbox}
\noindent
\begin{itemize}
    \item Definire $X_n$ al variare di $n$
    \item $X_n$ sono ricorsivi
    \item Dimostrare che $A = \{x \; | \; \bigcap_n \; \overline{X_n} \preceq W_x \}$
    \item Dimostrare che $A$ è produttivo
\end{itemize}
Capiamo cosa significa $\bigcap_n \overline{X_n} \preceq W_x$.
$W_x$ è sempre re per definizione. Mentre $\bigcap_n \overline{X_n}$ non è produttivo.
\[
    k \preceq W_x 
\]
Vuol dire che $W_x$ è re ma anche creativo.
\begin{itemize}
    \item Definiamo:
    \[
        \overline{X_n} = \{x \; | \; \varphi_x(x) \text{ termina in n passi}\}
        \quad X_n = \{x \; | \; \varphi_x(x) \text{ non termina in n passi}\} 
    \] 
    \item $\bigcup_n \overline{X_n} = k$ (esercizio 1)
    \item $A = \{x \; | \; k \preceq W_x \}$
    \item $A$ produttivo se $\overline{k} \preceq A$.
    \[
    \begin{aligned}
        x \in k &\implies g(x) \notin A \text{ ovvero $W_{g(x)}$ non creativo $\leadsto$ Ricorsivo}\\
        x \notin k &\implies g(x) \in A \text{ ovvero $W_{g(x)}$ creativo $\leadsto$ K (creativo)}
    \end{aligned}
    \]
    \[
        \psi(x,y) = \begin{cases}
            1 & x \in k \lor y \in k\\
            \uparrow & \text{se non termina}
        \end{cases}
    \]
    Con $\psi$ parziale ricorsiva.
\begin{lstlisting}[language=Python]
input(x,y)
costruisci phi_x, phi_y
while true
    esegui next step di phi_x(x)
    if termina: return 1
    esegui next step di phi_y(y)
    if termina: return 1
\end{lstlisting}
Per il teorema di s-m-n esiste una funzione totale e calcolabile $g$ tale che:
\[
    \varphi_{g(x)}(y) = \psi(x,y)
\]
\[
    \begin{aligned}
        x \in k &\implies \forall y \; . \; \psi(x,y)\downarrow\\
        &\implies \forall y \; . \; \varphi_{g(x)}(y) \downarrow \\
        &\implies W_{g(x)} = \mathbb{N}\\ 
        &\implies g(x) \notin A\\
    \end{aligned}
\]
\[ 
    \begin{aligned}
        x \notin k &\implies y \in k \iff \psi(x,y) \uparrow\\
        &\implies y \in k \iff \varphi_{g(x)}(y) \uparrow \\
        &\implies W_{g(x)} = k\\ 
        &\implies g(x) \in A\\
    \end{aligned}
\]
\end{itemize}

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 3}]
    Definire una successione di insiemi ricorsivi $X_n$ tale che
    \[  
        C = \{x \; | \; \bigcap_n \; X_n \preceq W_x \} \text{ sia ricorsivo}
    \]
\end{tcolorbox}
\noindent
Essendo che per definizione $W_x$ è sempre RE allora 
$\overline{k} \preceq W_x$ è sempre falso. Basta trovare 
una successione di insiemi ricorsivi
t.c he $\bigcap_n X_n = \overline{k}$ (esercizio 2). 
Per dimostrare che $C$ è ricorsivo basta notare che possiamo
ricondurci al problema di appartenenza a $\overline{k}$ che è ricorsivo.
\[
    C = \{x \; | \; \bigcap_n X_n \preceq W_x\} = \{x \; | \; \overline{k} \preceq W_x \} = \emptyset
\]

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 4}]
Successione di funzioni parziali ricorsive $\psi_n$ tali che $dom(\psi_n)$ 
sono re non completi (ricorsivi) e che 
\[  
    \bigcup_n \; dom(\psi_n) = \{x \; | \; 2x \in W_x\}
\]
\end{tcolorbox}
Sappiamo che $\bigcup_n$ corrisponde a $\exists n$.
\[
\{x \; | \; 2x \in W_x\} = \{x \; | \; \varphi_x(2x)\downarrow\}
\]
\begin{itemize}
    \item Definire $X_n = dom(\psi_n)$
    \item Dimostrare che $X_n$ sono ricorsivi 
    \item Mostrare che $\bigcup_n dom(\psi_n) = \{x \; | \; \varphi_x(2x)\downarrow\}$
\end{itemize}
Definiamo $\psi_n$ t.c. $X_n = dom(\psi_n)$:
\[ 
    \psi_n(x) = \begin{cases}
        1 & x \in X_n \land \varphi_x(2x) \text{ termina in n passi}\\
        \uparrow & \text{altrimenti}
    \end{cases}
\] 
Dimostriamo che $X_n$ è ricorsivo. (COMPLETARE)
\[ 
\begin{aligned}
    \bigcup_n dom(\psi_n) &\implies \{x \; | \; \exists n. x \in dom(\psi_n)\}\\
    &\implies \{x \; |\; \exists n. \varphi_x(2x) \text{ termina in passi}\} \\
    &\implies \{x \; | \; \varphi_x(2x)\downarrow\}
\end{aligned}
\]
\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 4}]
Successione di funzioni parziali ricorsive $\psi_n$ tali che $dom(\psi_n)$ 
sono re non completi (ricorsivi) e che 
\[  
    \bigcap_n \; dom(\psi_n) = \{x \; | \; \varphi_x(2^x + 2)\uparrow\}
\]
\end{tcolorbox}
\noindent
Sappiamo che $\bigcap_n$ corrisponde a $\forall n$.
Mentre la divergenza può essere vista come $\forall n$ non termina.
\[
    X_n = dom(\psi_n) = \{x \; | \; \varphi_x(2^x + 2) \text{ non termina in n passi}\} 
\]
\[
    \psi_n(x) = \begin{cases}
        1 & \varphi_x(2^x + 2) \text{ non termina in n passi}\\
        \uparrow & \text{altrimenti}
    \end{cases}
\]
Dimostra che $X_n$ è ricorsivo. (COMPLETARE)
\[
\begin{aligned}
    \bigcap_n \; dom(\psi_n) &\implies \{x \; | \; \forall n \; . \; x \in X_n\}\\
    &\implies \{x \; |\; \forall n. \varphi_x(2^x + 2) \text{ non termina in n passi}\} \\
    &\implies \{x \; | \; \varphi_x(2^x + 2)\uparrow\}
\end{aligned}
\]

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 4}]
Successione di funzioni parziali ricorsive $\psi_n$ tali che $Range(\psi_n)$ 
sono creativi e che 
\[  
    \bigcap_n \; Range(\psi_n) = \{x^2 \; | \; W_x = \mathbb{N}\}
\]
\end{tcolorbox}
Sappiamo che $\bigcap_n$ corrisponde a $\forall n$ e 
che $W_x = \mathbb{N}$ vuol dire che $\forall n \; .\; n \in W_x (\text{ovvero } \varphi_x(n) \downarrow)$.

\begin{itemize}
    \item 
    \[
        X_n = Range(\psi_n) = \{x^2 \; | \; \varphi_x(n)\downarrow\} = \{x^2\;  | \; n \in W_x\}
    \]
    \[
    \psi_n(x) = \begin{cases}
        x^2 & \varphi_x(n) \downarrow\\
        \uparrow & \text{altrimenti}
    \end{cases}
    \]
\end{itemize}
Dimostrare che $X_n$ è creativo. (dimostrare quindi che siano RE e che $k \preceq X_n$)
\[
\begin{aligned}
  \bigcap_n X_n = \bigcap_n Range(\psi_n) &= \{x^2 \; | \; \forall n \; . \; \varphi_x(n)\downarrow\}\\
  &= \{x^2 \; | \; W_x = \mathbb{N}\}   
\end{aligned}
\] 
\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 8}]
Successione di $X_n$ produttivi tale che $\bigcap_n X_n \preceq k$ ($k$ completo
$\Rightarrow \forall X \; re$ e $x \preceq k$).
\\
Una possibile soluzione potrebbe essere 
\[
\bigcap_n X_n = \varnothing
\]
può essere una soluzione in quanto $\varnothing \preceq k$ perché
$\varnothing$ è ricorsivo e quindi re. k completo. 
\end{tcolorbox}
\[
    X_n = \{x \; | \; W_x = [0,n]\} \forall m \neq n \; . \; W_x \neq [0,m] 
\]
\[
    \bigcap X_n = \varnothing \quad \begin{aligned}
        y \in X_n &\implies W_y = [0,n] \neq [0,n+1]\\
        &\implies y \notin X_{n+1} 
    \end{aligned}
\]
visto genericità di $y$ e $n$ allora $\bigcap X_n = \varnothing$.
$\varnothing \preceq k$ perché $k$ completo (Sol. alternativa: $X_n = \{x \; | \; W_x = n\mathbb{N}\}$ o $\{x \; | \; W_x = \{n\}^{\mathbb{N}}\}$).

\begin{tcolorbox}[colback=gray!5, colframe=gray!50, title=\textbf{Esercizio 9}]
\[
    D_n = Dom(\psi_n)
\]
\[
    \psi_n(x) = \begin{cases}
        \lceil\sqrt{n+x}\rceil & 4x+1 \in 2\mathbb{N} +1 \land 4x + 1 \in W_x \text{ non termina in meno di $n$ passi}\\
        \uparrow & \text{ altrimenti}
    \end{cases}
\]
Presa la seguente successione di insiemi:
\[
    X_n = \{ \lceil\sqrt{x}\rceil \; | \; n \in W_x\}
\]
\[
    S = \bigcap_{n \in R} X_n 
\]
\[  
    R = \bigcap_{n \ge 3} D_n
\]
Studiare l'insieme S.
\end{tcolorbox}
\noindent
Sappiamo che per esempio l'insieme $D_3$ è fatto:
\[
D_3 = \{x \;|\; 4x+1 \notin W_x \text{ in meno di 3 passi}\}
\]
E così via per gli altri $D_n$. 
\[
    R = \bigcap_{n \ge 3} D_n = \{x \; | \; 4x + 1 \notin W_x\}
\]
quindi 
\[
    S = \bigcap_{n \in R} X_n = \{\lceil\sqrt{x}\rceil \; | \; W_x = \{x \; | \; 4x + 1 \notin W_x\}\}
\]














\end{document}