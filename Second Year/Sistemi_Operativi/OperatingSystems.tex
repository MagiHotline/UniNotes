\documentclass[a4paper]{article}
\usepackage{import}
\input{../../setup.sty}
\title{Operating Systems Writeup}
\author{SETU - South East Technological University\\Imbriani Paolo - W20114452\\Professor Micheal McMahon}

\begin{document}

\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{SETU.png}
    \label{fig:centered-image}
\end{figure}

\maketitle 

\pagebreak

\tableofcontents

\pagebreak

\section{Practical 1 -  Commands}


\textcolor{green!50!black}{
Taking a selection of Windows CLI commands from those given below, use the online help to
examine the various options and arguments, and try them out.\\
You're required carefully to write two A4 pages (Times 12 point or equivalent size) detailing your experiments with different options for between six and ten different commands.
To get the online help for a command, type command /?\\
e.g.\\
dir /?\\
prompt\\
mkdir\\
color\\
title\\
tree\\
type\\
ver\\
print\\
xcopy\\
Type help at the windows command line prompt to see some more instructions
}

\begin{itemize}
    \item Prompt - The prompt command is used to customize the text that appears before the cursor in the command prompt.
\begin{lstlisting}[language=bash]
prompt MyPrompt$G
\end{lstlisting}
This changes the prompt to MyPrompt$>$. The \$G represents the $>$ symbol.
\item Mkdir - The mkdir command is used to create a new directory.
\begin{lstlisting}[language=bash]
mkdir MyDirectory
\end{lstlisting}
This creates a new directory called MyDirectory. To create a folder inside another folder:
\begin{lstlisting}[language=bash]
mkdir MyDirectory\MySubDirectory
\end{lstlisting}
\item Color - The color command is used to change the color of the text and background in the command prompt.
\begin{lstlisting}[language=bash]
color 0A
\end{lstlisting}
This sets a black background (0) with green text (A).
To reset to default:
\begin{lstlisting}[language=bash]
color
\end{lstlisting}
To see all the available colors:
\begin{lstlisting}[language=bash]
color /?
\end{lstlisting}
\item Title - The title command is used to change the title of the command prompt window.
\begin{lstlisting}[language=bash]
title MyTitle
\end{lstlisting}
This changes the title of the command prompt window to MyTitle.
\item Tree - The tree command is used to display a graphical representation of the directory structure.
\begin{lstlisting}[language=bash]
tree
\end{lstlisting}
And it will output something like this:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{treeEx.png}
\end{figure}
Displays a simple tree structure of folders in the current directory. To include all files in the display:
\begin{lstlisting}[language=bash]
tree /f
\end{lstlisting}
The /F option lists all files along with the folder structure.
\item Type - The type command is used to display the contents of a text file.   
\begin{lstlisting}[language=bash]
type MyFile.txt
\end{lstlisting}
This displays the contents of the file MyFile.txt. Useful for quickly viewing small text files without opening them.
\item Ver - The ver command is used to display the version of the operating system.
\begin{lstlisting}[language=bash]
ver
\end{lstlisting}
This displays the version of the operating system.


\end{itemize}
\textcolor{green!50!black}{What’s the purpose of the first line - @ECHO OFF? Remove it and see the
effect}

\begin{lstlisting}[language=bash]
@ECHO OFF
ECHO Please insert a USB memory stick
PAUSE
COPY *.txt I:\
ECHO BACKUP COMPLETE
\end{lstlisting}
\begin{itemize}
    \item @ECHO OFF → Hides command execution lines for cleaner output.
    \item ECHO → Displays messages on the screen.
    \item PAUSE → Waits for the user to press a key before continuing.
    \item COPY *.txt I:\ → Copies all .txt files from the current folder to the USB drive (assuming it's drive I:).
    \item ECHO BACKUP COMPLETE → Displays a completion message.
\end{itemize}
The first line, @ECHO OFF, is used to prevent the command prompt from displaying each command as it executes.
\begin{lstlisting}[language=bash]
C:\Users\YourName\Desktop> ECHO Please insert a USB memory stick
Please insert a USB memory stick

C:\Users\YourName\Desktop> PAUSE
Press any key to continue . . .

C:\Users\YourName\Desktop> COPY *.txt I:\
3 file(s) copied.

C:\Users\YourName\Desktop> ECHO BACKUP COMPLETE
BACKUP COMPLETE
\end{lstlisting}

\section{Practical 2 -  Powershell}

\textcolor{green!50!black}{
    2.1 Test the above using a directory that you created last week.
}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{os1.png}
\end{figure}
\noindent
Using the directory was created last week, we can use the Get-ChildItem command to list the contents of the directory.
using the following list of commands:
\begin{minted}{bash}
$mylist = dir 
$mylist
$mylist[0].Name
$mylist[0].length
$mylist[0].Mode
$mylist[0].LastWriteTime
\end{minted}
\noindent
\textcolor{green!50!black}{
Exercise of bash scripting in Powershell:
\begin{itemize}
    \item Simply record what happens when you run this script.
    \item Find out how to run scripts if they’re in a directory other than the working directory.
    \item Study the following script and see if you can figure out what it’ll do. Now type it into a file called game.ps1 (You can use copy/paste in places to reduce the labour.) Run it and see if your predictions are true.
\end{itemize}
}

\begin{minted}{bash}
###########################################################
###########################################################
##
## The three pathetic knock-knock jokes program!
## Date: 26/09/17
## For: BSc (Hons) Computer Forensics and Security
##
###########################################################
###########################################################

############################
## initialisation section
############################
$userReply = ""
############################
## first question
############################
Clear-Host

while($userReply -ne "Who is there?"){
    $userReply = read-host "Knock Knock!"
}
Clear-Host
while($userReply -ne "Orange who?"){
    $userReply = read-host "Orange"
}
Clear-Host
Write-Output "Orange you glad you created this PowerShell script?"
Start-Sleep -Seconds 5
############################
## Second Question
############################
Clear-Host
while($userReply -ne "Who is there?"){
    $userReply = read-host "Knock Knock!"
}
Clear-Host
while($userReply -ne "Orange who?"){
    $userReply = read-host "Orange"
}
Clear-Host
Write-Output "Oranges are oranges but this is PowerShellscripting!"
Start-Sleep -Seconds 5
############################
## Third Question
############################
Clear-Host
while($userReply -ne "Who is there?"){
    $userReply = read-host "Knock Knock!"
}
Clear-Host
while($userReply -ne "Banana who?"){
    $userReply = read-host "Banana"
}
Clear-Host
Write-Output "Orange you glad I didn't say orange?"
Start-Sleep -Seconds 5
############################
## Farewell Message
############################
Clear-Host
Write-Output "Goodbye!nn"    
\end{minted}
When you run game.ps1, here’s the interactive sequence you’ll experience:

\begin{enumerate}
    \item The script will prompt you with “Knock Knock!”
    \item You’ll need to respond with “Who is there?”
    \item The script will then prompt you with “Orange”
    \item Until you respond with “Orange who?”
    \item The script will then output “Orange you glad you created this PowerShell script?”
    \item The second and third questions follow a similar pattern.
    \item The script will then output “Goodbye!”
\end{enumerate}
\textcolor{green!50!black}{
To do:
\begin{enumerate}
    \item Create another file called beverage.txt identical to drink.txt.
    (Hint: Use what you learned in practical 1 to do this.)
    \item Issue this command again\\
    Get-ChildItem | select-string coffee\\
    and see what happens.
    \item Create a file called fruit.txt with the list apple, orange, banana in it.
    \item Issue this command again\\
    Get-ChildItem | select-string coffee\\
    and see what happens.
\end{enumerate}
}
\begin{minted}{bash}

PS C:\Users\User1\green> Copy-Item drink.txt beverage.txt
PS C:\Users\User1\green> Get-ChildItem *.txt
Directory: C:\Users\User1\green

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-a----        2/10/2025   10:15 AM           123 drink.txt
-a----        2/10/2025   10:15 AM           123 beverage.txt
PS C:\Users\User1\green> Get-ChildItem | Select-String coffee
drink.txt:1:coffee.
beverage.txt:1:coffee.
PS C:\Users\User1\green> Set-Content fruit.txt -Value "apple`r`norange`r`nbanana"
PS C:\Users\User1\green> Get-Content fruit.txt
apple
orange
banana
PS C:\Users\User1\green> Get-ChildItem | Select-String coffee
drink.txt:1:coffee.
beverage.txt:1:coffee.
\end{minted}
\noindent
\textcolor{green!50!black}{
Find out and explain how to get help about any cmdlet.
\begin{itemize}
    \item Find out and explain what F7 does in PowerShell.
    \item  What is the purposes of (a) the –whatif switch and (b) the –confirm
    \item Write a note to explain how you can use tab to complete a command as soon as
    it’s unambiguous.  
\end{itemize}
}
\noindent
In PowerShell, you can obtain help for any cmdlet by typing Get-Help followed by the name of the cmdlet.
\begin{minted}{bash}
Get-Help Get-Process
\end{minted}
This will display detailed information about the Get-Process cmdlet, including a description, syntax, parameters, examples, and more.
When you press F7 in a PowerShell console, it brings up a graphical popup window displaying your command history from the current session.
You can use the arrow keys to navigate through the list of previously executed commands. This is a handy feature to quickly recall and reuse commands without retyping them.
\\
The -WhatIf switch is used to simulate the execution of a command. It shows you what would happen if the command ran but does not make any actual changes.
Use -WhatIf with potentially destructive or impactful commands to verify what actions would be performed.
\begin{minted}{bash}
Remove-Item C:\Temp\* -WhatIf
\end{minted}
The -Confirm switch forces the command to prompt for your confirmation before executing each action. This extra safety measure helps prevent accidental changes.
\begin{minted}{bash}
Remove-Item C:\Temp\* -Confirm
\end{minted}
\noindent
PowerShell supports intelligent tab completion. As you start typing a command, cmdlet name, parameter, or even file path, you can press the Tab key to auto-complete the text.
If the text you've entered uniquely identifies a command or parameter, pressing Tab will automatically complete it.
If \textbf{multiple completions are possible repeatedly pressing Tab cycles through the available options until you reach the one you want.}


\section{Practical 3 -  Powershell Part 2}

\begin{minted}{bash}
$name = Read-Host "Please type your name"
Write-Host "Hello" $name
\end{minted}
\textcolor{green!50!black}{
    Simply record what happens when you run this script. What difference
    does it make if you leave out the text "Please type your name" from the first line of
    the script?
} 
\noindent
What happens: 
\begin{enumerate}
    \item Powershell prompts you with: "Please type your name:"
    \item You enter a name (e.g., John).
    \item Powershell outputs: "Hello John"
    \item If you don't put the text "Please type your name" in the Read-Host command, Powershell will prompt you with a blank line instead of the text.
\end{enumerate}
\textcolor{green!50!black}{
    Find out how to run scripts if they’re in a directory other than the
    working directory.
}
By default, PowerShell restricts script execution for security reasons. You may need to change the execution policy before running scripts:
If your script is stored in \texttt{C:$\backslash$Scripts$\backslash$myscript.ps1} and your working directory is elsewhere, you can run it using:
\begin{minted}{bash}
C:\Scripts\myscript.ps1
\end{minted}
or explicitly call PowerShell:
\begin{minted}{bash}
powershell -ExecutionPolicy Bypass -File C:\Scripts\myscript.ps1
\end{minted}
\begin{minted}{bash}
$inputString = read-host
$value = $inputString -as [Double]
write-host "You entered: $value"
\end{minted}
\textcolor{green!50!black}{
    (a) Find out how to do the same thing that the code above does except
    that it’ll only accept integers (such as 67). (b) Once you’re found the answer, find out
    what happens if you type a real number (such as 67.4 or 67.8)}
\begin{itemize}
    \item[a)] To only accept integers, you can use [Int] instead of [Double]:
     \begin{minted}{bash}
     $value = $inputString -as [Int]
    \end{minted}
    \item[b)] If you type a real number, PowerShell will round the number down to the nearest integer.
\end{itemize}
\begin{minted}{bash}
do

    write-host -nonewline "Enter a numeric value: "
    $inputString = read-host
    $value = $inputString -as [Double]
    $ok = $value -ne $NULL
    if ( -not $ok ) { write-host "You must enter a numeric value" }
}
until ( $ok )
write-host "You entered: $value"
\end{minted}
\textcolor{green!50!black}{
    Alter the above program (in brown) to require the user to enter
    specifically integer values between 1 and 4 inclusive.
}
\begin{minted}{bash}
do
{
    write-host -nonewline "Enter an integer value (1-4): "
    $inputString = read-host
    $value = $inputString -as [Int]  
    $ok = ($value -ne $NULL) -and ($value -ge 1) -and ($value -le 4) 
    
    if ( -not $ok ) { write-host "Invalid input. Please enter a whole number between 1 and 4." }
}
until ( $ok )

write-host "You entered: $value"
\end{minted}
\begin{minted}{bash}
---------------------------------------------------------
$i = 1
while ($i -le 20)
{
 if(($i -ne 13) -and ($i -ne 17))
 {
Write-Host $i
 }
 $i = $i + 1
}
\end{minted}

\textcolor{green!50!black}{
\begin{itemize}
    \item What does the above script do?
    \item We don’t need the brackets round (i -ne 13) and (i -ne 17) in the code
above. Why do we not need them? (Hint: The answer is the same as for Java). Do
you think that it’s a good idea to put them in even if they aren’t necessary? Explain
your answer.
\end{itemize}
}

\begin{itemize}
    \item \begin{itemize}
        \item Initialize i = 1
        \item Loop while i $<=$ 20
        \item Condition Check: If i is not 13 and i is not 17, print i
        \item Otherwise, skip printing.
        \item Increment i by 1 each loop iteration.
        \item Repeat until i exceeds 20.
    \end{itemize}
    \item In PowerShell (like in Java), comparison operators are evaluated first. Is it a good idea to include them anyway?
     Using parentheses is optional but can be a good habit for clarity, especially in more complex conditions.
\end{itemize}
\begin{minted}{bash}   
for($i = 1; $i -le 8; $i = $i + 1)
{
Write-Host $i
}
\end{minted}
\textcolor{green!50!black}{
We can replace $i = $i + 1 with something shorter, in the above two
scripts. What do you think it is? Try it and see.
}
It's \texttt{\$i++}.
\begin{minted}{bash}
do
{
    Write-Host $i;
    $i = $i + 1;
} until ($i -eq 10);
\end{minted}
\textcolor{green!50!black}{
Oops, I've put semicolons at the end of each of the lines, in the do...until
loop above. I suppose it's because of my experience in writing programs in other
languages that sometimes I put semicolons at the end of a line of PowerShell script,
even when they're entirely unnecessary in PowerShell. Does PowerShell forgive me
for doing this? Find out, and write your conclusion.
}
The script runs normally without errors. The semicolons do not break execution since PowerShell treats them as harmless separators.
\begin{minted}{bash}
$temperature = 1
switch($temperature)
{
 { $_ -lt 0 } { "Below Freezing"; break }
 0 { "Exactly Freezing"; break }
 { $_ -le 10 } { "Cold"; break }
 { $_ -le 20 } { "Warm"; break }
 default { "Hot" }
}
\end{minted}
\textcolor{green!50!black}{
    Alter this program to deal with grade categories (for example $>$70 is a
    distinction mark etc) in an examination and also allow the user to enter a grade.
}
\begin{minted}{bash}
$grade = Read-Host "Enter your exam grade"

switch ($grade -as [int])  
{
    { $_ -ge 70 } { "Distinction"; break }
    { $_ -ge 60 } { "Merit"; break }
    { $_ -ge 50 } { "Pass"; break }
    { $_ -ge 40 } { "Borderline Fail"; break }
    default { "Fail" }
}
\end{minted}
\begin{minted}{bash}
$listing = dir
$howLong = $listing.Length
$i = 0;
while($i -lt $howLong)
{
Write-Host $listing[$i].Name
$i++
}
\end{minted}
\textcolor{green!50!black}{
    1. Explain what the above example does. Modify it to show fields other
    than the Name field.
    2. Draw up a chart to show equivalent syntaxes for different control
    structures/data structures among Java, Unix script, and PowerShell. You'll have to
    revisit this question when you've learned some Unix/Linux.
    3. Compare the ways in which scripts are enabled to run in (a)
    Unix/Linux and (b) PowerShell. Again this is a question for review when you've
    done some Unix/Linux.
}
\begin{enumerate}
    \item Retrieves a list of files and directories in the current directory (dir is an alias for Get-ChildItem).
    \item Iterates through the list and prints the name of each item.
    \item Prints the Name property of each file/directory (\$listing[\$i].Name).
    \item Increments \$i by 1 in each iteration.
\end{enumerate}
To show additional fields like Size, LastWriteTime, and Mode, modify the script as follows:
\begin{minted}{bash}
$listing = dir
$howLong = $listing.Length
$i = 0
while($i -lt $howLong)
{
    Write-Host "$($listing[$i].Mode) $($listing[$i].Length) 
    $($listing[$i].LastWriteTime) $($listing[$i].Name)"
    $i++
}
\end{minted}
\small
\begin{table}[h]
 \hspace{-2cm}
\renewcommand{\arraystretch}{1.2} % Spaziatura compatta
\begin{tabular}{|p{3cm}|p{4cm}|p{4cm}|p{3cm}|}
    \hline
    \textbf{Concept	} & \textbf{PowerShell} & \textbf{Java} & \textbf{Bash} \\
    \hline
    Variable Assignment & \texttt{\$x = 5} & \texttt{int x = 5;} & \texttt{x=5} \\
    \hline
    If & \texttt{if (\$x -gt 10) \{ ... \}} & \texttt{if (x > 10) \{ ... \}} & \texttt{if [ \$x -gt 10 ]; then ... fi} \\
    \hline
    For & \texttt{for (\$i=0; \$i -lt 10; \$i++)} & \texttt{for (int i=0; i<10; i++)} & \texttt{for i in \{0..9\}; do ... done} \\
    \hline
    While & \texttt{while (\$x -lt 10)} & \texttt{while (x < 10)} & \texttt{while [ \$x -lt 10 ]; do ... done} \\
    \hline
    Switch & \texttt{switch (\$var) \{ ... \}} & \texttt{switch (var) \{ case 1: ... \}} & \texttt{case \$var in ... esac} \\
    \hline
    Array & \texttt{\$arr = @(1,2,3)} & \texttt{int[] arr = \{1,2,3\}} & \texttt{arr=(1 2 3)} \\
    \hline
    Function & \texttt{function MyFunc \{ ... \}} & \texttt{int myFunc(int x) \{ ... \}} & \texttt{my\_func() \{ ... \}} \\
    \hline
\end{tabular}
\caption{Syntax between PowerShell, Java e Bash}
\end{table}
\begin{table}[h]
\hspace{-1.5cm}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|p{3.5cm}|p{5cm}|p{5cm}|}
    \hline
    \textbf{Feature} & \textbf{PowerShell} & \textbf{Unix/Linux} \\
    \hline
    Default Script Execution & Disabled for security (Restricted mode) & Allowed but may require execution permissions. \\
    \hline
    Checking Execution Policy & \texttt{Get-ExecutionPolicy} & \texttt{ls -l script.sh} \\
    \hline
    Allowing Script Execution & \texttt{Set-ExecutionPolicy RemoteSigned} & \texttt{chmod +x script.sh} \\
    \hline
    Running a Script & \texttt{.\textbackslash script.ps1} & \texttt{./script.sh} \\
    \hline
    Running from Another Directory & \texttt{C:\textbackslash Scripts\textbackslash script.ps1} & \texttt{/home/user/script.sh} \\
    \hline
    Running Without Changing Directory & \texttt{\& "C:\textbackslash Scripts\textbackslash script.ps1"} & \texttt{bash /path/to/script.sh} \\
    \hline
\end{tabular}
\caption{Comparison between the execution in PowerShell e Unix/Linux}
\end{table}






\end{document}